# Лабораторная № 2 по дисциплине "Параллельное программирование"

## Постановка задачи
Реализовать параллельное вычисление обратной матрицы. В качестве алгоритма решения задачи был выбран метод Гаусса-Жордана.

## Использование
```
mvn package

java -jar target/matrix-inversion-1.0.jar <pathToFile> <threadCount>
```

* _pathToFile_ - путь к файлу, содержащему матрицу;
* _threadCount_ - количество используемых тредов.

## Описание веток
* _master_ - реализация, основанная на ExecutorService и Future;
* _using-latches_ - реализация, основанная на CountDownLatches и разделении задачи на блоки (подход похож на примененный в работе по Nvidia CUDA);
* _proof-of-concept_ - содержит демонстрацию упомянутого принципа, схожего с примененным в работе по Nvidia CUDA. Может быть интересен для выполения других лабораторных.

## Описание generate_matrix.py
__generate_matrix.py__ - скрипт для генерации случайной матрицы. Строчки, связанные с вычислением определителя для проверки существования обратной матрицы закомментированы ввиду возникающего overflow при вводе размера матрицы большего ~200. Не факт, что так будет на другом ПК :)

Использование:
```
python generate_matrix.py <n> <pathToDir>
```

## Комментарий
То ли я дурак, то ли лыжи не едут. Программа начинает зависать при указании количества тредов большего ~16. На небольших размерах матриц время параллельного вычисления сильно превосходит время выполнения с одним тредом; на бОльших размерах с бОльшим количесвтом тредов эксперимент провести не удаётся.

 (всё вышесказанное относится к запускам на собственном ПК на момент коммита "added readme")